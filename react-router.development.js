import{createMemoryHistory,parsePath}from'history';import PropTypes from'prop-types';import React from'react';function k(a,b){if(!a)throw Error(b);}let l=React.createContext();l.Consumer.displayName="Location.Consumer";l.Provider.displayName="Location.Provider";let n=React.createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});n.Consumer.displayName="Route.Consumer";n.Provider.displayName="Route.Provider";
function p({children:a,initialEntries:b,initialIndex:c,timeout:e}){let d=React.useRef(null);null==d.current&&(d.current=createMemoryHistory({initialEntries:b,initialIndex:c}));return React.createElement(r,{children:a,history:d.current,timeout:e})}p.displayName="MemoryRouter";
p.propTypes={children:PropTypes.node,timeout:PropTypes.number,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number};function t({to:a,replace:b=!1,state:c}){u()(a,{replace:b,state:c});return null}t.displayName="Navigate";
t.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function v(){return w()}v.displayName="Outlet";v.propTypes={};function x(){return null}x.displayName="Redirect";
x.propTypes={children:function(a,b){if(null!=a[b])return Error("A <Redirect> should not have child routes; they will never be rendered.")},from:PropTypes.string,to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})])};function y({element:a}){return a}y.displayName="Route";y.propTypes={children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};let z=a=>a(),A=React.useTransition||(()=>[z,!1]);
function r({children:a=null,history:b,timeout:c=2E3}){let [e,d]=React.useState(b.location),[g,f]=A({timeoutMs:c});c=React.useRef(!1);React.useContext(l)?k(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):void 0;c.current||(c.current=!0,b.listen(({location:b})=>{g(()=>{d(b)})}));return React.createElement(l.Provider,{children:a,value:{history:b,location:e,pending:f}})}r.displayName="Router";
r.propTypes={children:PropTypes.node,history:PropTypes.shape({action:PropTypes.string,location:PropTypes.object,push:PropTypes.func,replace:PropTypes.func,go:PropTypes.func,listen:PropTypes.func,block:PropTypes.func}),timeout:PropTypes.number};function B({basename:a="",caseSensitive:b=!1,children:c}){c=C(c);return D(c,a,b)}B.displayName="Routes";B.propTypes={basename:PropTypes.string,caseSensitive:PropTypes.bool,children:PropTypes.node};
function C(a){let b=[];React.Children.forEach(a,a=>{if(React.isValidElement(a)){var {children:c,from:d,path:g,to:f}=a.props;if(a.type===React.Fragment)b.push.apply(b,C(c));else{g=g||d||"/";if(f)a={path:g,redirectTo:f};else{a={path:g,element:a};let b=C(c);b.length&&(a.children=b)}b.push(a)}}});return b}function E(){return React.useContext(l).location}
function u(){let {history:a,pending:b}=React.useContext(l),{pathname:c}=React.useContext(n);null==a?k(!1,"navigation may be used only in the context of a <Router> component"):void 0;return React.useCallback((e,{replace:d,state:g}={})=>{"number"===typeof e?a.go(e):(e=F(e,c),a[d||b?"replace":"push"](e,g))},[a,b,c])}function w(){return React.useContext(n).outlet}function G(a){let {pathname:b}=React.useContext(n);return React.useMemo(()=>F(a,b),[a,b])}let H,I;H={};
I=(a,b,c)=>{if(!b&&!H[a]){H[a]=!0;"undefined"!==typeof console&&console.warn(c);try{throw Error(c);}catch(e){}}};
function D(a,b="",c=!1){let {params:e,pathname:d,route:g}=React.useContext(n);if(I){var f=g&&g.path;I(d,!g||g.path.endsWith("*"),`You rendered descendant <Routes> (or called \`useRoutes\`) at "${d}"`+` (under <Route path="${f}">) but the parent route path has no trailing "*".`+" This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n"+`Please change the parent <Route path="${f}"> to <Route path="${f}/*">.`)}b=b?[d,b].join("/").replace(/\/\/+/g,
"/"):d;f=u();let q=E();var h=React.useMemo(()=>J(a,q,b,c),[a,q,b,c]);if(!h)return null;var m=h.find(a=>null!=a.route.redirectTo);if(m){let {params:a,route:b}=m;h=F(b.redirectTo,d);({pathname:m}=h);/:\w+/.test(m)&&(h={...h,pathname:K(m,a)});f(h,{replace:!0});return null}return h.reduceRight((a,{params:c,pathname:d,route:f})=>React.createElement(n.Provider,{children:f.element,value:{outlet:a,params:Object.freeze({...e,...c}),pathname:[b,d].join("/").replace(/\/\/+/g,"/"),route:f}}),null)}
function J(a,b,c="",e=!1){"string"===typeof b&&(b=parsePath(b));c=c.replace(/^\/+|\/+$/g,"");let d=b.pathname.slice(1);if(c)if(c===d)d="";else if(d.startsWith(c))d=d.slice(c.length).replace(/^\/+/,"");else return null;a=L(a);M(a);for(b=0;b<a.length;++b){let [g,f]=a[b];[c]=N(g,!0,e);if(c.test(d))return f.map((a,b)=>{b=f.slice(0,b+1).map(a=>a.path).join("/").replace(/\/\/+/g,"/");let [c,g]=N(b,!1,e);b=d.match(c);return{params:O(g,b.slice(2)),pathname:"/"+b[1],route:a}})}return null}
function L(a,b=[],c="",e=[],d=[]){a.forEach((a,f)=>{let g=[c,a.path].join("/").replace(/\/\/+/g,"/"),h=e.concat(a);f=d.concat(f);b.push([g,h,f]);a.children&&L(a.children,b,g,h,f)});return b}let P=/^:\w+$/,Q=a=>"*"===a;function R(a){a=a.split("/");let b=a.length;a.some(Q)&&(b+=-2);return a.filter(a=>"*"!==a).reduce((a,b)=>a+(P.test(b)?2:""===b?1:10),b)}function M(a){let b=a.reduce((a,[b])=>{a[b]=R(b);return a},{});a.sort((a,e)=>{let [c,,g]=a;a=b[c];let [f,,q]=e;e=b[f];return a!==e?e-a:S(g,q)})}
function S(a,b){return a.length===b.length&&a.slice(0,-1).every((a,e)=>a===b[e])?a[a.length-1]-b[b.length-1]:0}function N(a,b,c){let e=[],d="^("+a.replace(/^\/+/,"").replace(/\*\//g,"").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{e.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(d+="\\/?"),e.push("*"),d+="(.*)"):b&&(d+="\\/?");b&&(d+="$");return[new RegExp(d,c?void 0:"i"),e]}
function O(a,b){return a.reduce((a,e,d)=>{a[e]=b[d];return a},{})}function T(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}function F(a,b="/"){let {pathname:c,search:e="",hash:d=""}="string"===typeof a?parsePath(a):a;return{pathname:c?c.startsWith("/")?T(c,"/"):T(c,b):b,search:e,hash:d}}
function K(a,b={}){return a.replace(/:(\w+)/g,(a,e)=>b[e]||`:${e}`).replace(/\*$/,a=>b[a]||a)}
function useBlocker(a,b=!0){let {history:c}=React.useContext(l);null==c?k(!1,"navigation blocking may be used only in the context of a <Router> component"):void 0;React.useEffect(()=>{if(b){let b=c.block(c=>{a({...c,retry(){b();c.retry()}})});return b}},[c,b,a])};function useHref(a){a=G(a);let {history:b}=React.useContext(l);null==b?k(!1,"href resolution may be used only in the context of a <Router> component"):void 0;return b.createHref(a)};
function useMatch(a){let b=E();a=G(a);return b.pathname===a.pathname};function useParams(){return React.useContext(n).params};
function useRouteMatch(a,b="",c=!1){let {params:e,pathname:d}=React.useContext(n);b=b?[d,b].join("/").replace(/\/\/+/g,"/"):d;let g=E(),f=React.useMemo(()=>J([{path:a,element:null,children:null}],g,b,c),[a,g,b,c]);return React.useMemo(()=>{if(!f||!f[0])return null;let {pathname:a,params:c}=f[0];return{params:Object.freeze({...e,...c}),pathname:[b,a].join("/").replace(/\/\/+/g,"/")}},[b,f,e])};export{p as MemoryRouter,t as Navigate,v as Outlet,x as Redirect,y as Route,r as Router,B as Routes,C as createRoutesFromChildren,K as generatePath,J as matchRoutes,F as resolveLocation,useBlocker,useHref,E as useLocation,useMatch,u as useNavigate,w as useOutlet,useParams,G as useResolvedLocation,useRouteMatch,D as useRoutes}
//# sourceMappingURL=react-router.development.js.map
